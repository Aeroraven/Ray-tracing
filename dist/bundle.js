(()=>{"use strict";class e{static log(e){}}class t{constructor(e){this.gl=e}loadShader(e,t){const n=this.gl.createShader(e);return this.gl.shaderSource(n,t),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)?n:(console.log("[CGProject] Failed To Compile Shader"),console.log(this.gl.getShaderInfoLog(n)),this.gl.deleteShader(n),null)}initShaderProgram(t,n){e.log("Compiling Vertex Shader");const r=this.loadShader(this.gl.VERTEX_SHADER,t);e.log("Compiling Fragment Shader");const i=this.loadShader(this.gl.FRAGMENT_SHADER,n),a=this.gl.createProgram();return this.gl.attachShader(a,r),this.gl.attachShader(a,i),this.gl.linkProgram(a),this.gl.getProgramParameter(a,this.gl.LINK_STATUS)?(console.log("[CGProject] Shader created"),a):(console.log("[CGProject] Failed to initialize the shader"),console.log(this.gl.getProgramInfoLog(a)),null)}}class n{constructor(e){this.gl=e,this.vertexShader="",this.fragmentShader=""}getVertexShader(){}getFragmentShader(){}getShaderProgramEx(e,n){return new t(this.gl).initShaderProgram(e,n)}}class r{constructor(e,t,n){this.pt=e,this.cl=t,this.tx=null==n?[0,0]:n}}var i=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array;function s(){var e=new a(3);return a!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),s();class o{constructor(e,t,n){this.x=e,this.y=t,this.z=n}add(e){return new o(this.x+e.x,this.y+e.y,this.z+e.z)}dot(e){return new o(this.x*e.x,this.y*e.y,this.z*e.z)}cross(e){return new o(y*e.z-z*e.y,-x*e.z+z*e.x,x*e.y-y*e.x)}neg(){return new o(-this.x,-this.y,-this.z)}set(e,t,n){this.x=e,this.y=t,this.z=n}getGLMatVec3(){let e=s();return e[0]=this.x,e[1]=this.y,e[2]=this.z,e}dist(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}norm(){let e=this.dist();return new o(this.x/e,this.y/e,this.z/e)}magnify(e){return new o(this.x*e,this.y*e,this.z*e)}}class h{constructor(){this.light=new o(1,1,1)}setLight(e){this.light=e}}class c{constructor(e){this.gl=e,this.fb=e.createFramebuffer(),this.depBuf=e.createRenderbuffer(),this.depth=!1}bindTexture(e,t,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,this.fb),r.bindTexture(r.TEXTURE_2D,t.getTexture()),r.framebufferTexture2D(r.FRAMEBUFFER,e,r.TEXTURE_2D,t.getTexture(),t,0),this.depth=n,n&&(r.bindRenderbuffer(r.RENDERBUFFER,this.depBuf),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,t.getW(),t.getH()),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,this.depBuf)),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}bindTexturePingPong(e,t,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,this.fb),r.bindTexture(r.TEXTURE_2D,t.getTexture()),r.framebufferTexture2D(r.FRAMEBUFFER,e,r.TEXTURE_2D,n.getTexture(),0),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}start(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.fb)}end(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}}function l(){var e=new a(4);return a!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}l();class u{constructor(e,t,n,r){this.r=e,this.g=t,this.b=n,this.a=r}getGLMatVec4(){let e=l();return e[0]=this.r,e[1]=this.g,e[2]=this.b,e[3]=this.a,e}}function d(){var e=new a(16);return a!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}var f=function(e,t,n){var r=t[0],i=t[1],a=t[2],s=t[3],o=t[4],h=t[5],c=t[6],l=t[7],u=t[8],d=t[9],f=t[10],g=t[11],v=t[12],m=t[13],x=t[14],p=t[15],y=n[0],R=n[1],T=n[2],b=n[3];return e[0]=y*r+R*o+T*u+b*v,e[1]=y*i+R*h+T*d+b*m,e[2]=y*a+R*c+T*f+b*x,e[3]=y*s+R*l+T*g+b*p,y=n[4],R=n[5],T=n[6],b=n[7],e[4]=y*r+R*o+T*u+b*v,e[5]=y*i+R*h+T*d+b*m,e[6]=y*a+R*c+T*f+b*x,e[7]=y*s+R*l+T*g+b*p,y=n[8],R=n[9],T=n[10],b=n[11],e[8]=y*r+R*o+T*u+b*v,e[9]=y*i+R*h+T*d+b*m,e[10]=y*a+R*c+T*f+b*x,e[11]=y*s+R*l+T*g+b*p,y=n[12],R=n[13],T=n[14],b=n[15],e[12]=y*r+R*o+T*u+b*v,e[13]=y*i+R*h+T*d+b*m,e[14]=y*a+R*c+T*f+b*x,e[15]=y*s+R*l+T*g+b*p,e};class g{constructor(){this.projectionMat=d(),this.modelViewMat=d(),this.camPositon=new o(0,0,0),this.camCenter=new o(0,0,0),this.camUp=new o(0,0,0),window.r=this.modelViewMat}setPerspective(e,t,n,r){!function(e,t,n,r,i){var a,s=1/Math.tan(t/2);e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(a=1/(r-i),e[10]=(i+r)*a,e[14]=2*i*r*a):(e[10]=-1,e[14]=-2*r)}(this.projectionMat,e,t,n,r)}setOrtho(e,t,n,r,i,a){!function(e,t,n,r,i,a,s){var o=1/(t-n),h=1/(r-i),c=1/(a-s);e[0]=-2*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*h,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*o,e[13]=(i+r)*h,e[14]=(s+a)*c,e[15]=1}(this.projectionMat,e,t,r,n,i,a)}setCamPosition(e){this.camPositon=e}setCamCenter(e){this.camCenter=e}setCamUp(e){this.camUp=e}translate(e){this.camCenter.add(e),this.camPositon.add(e)}generate(){var e,t,n,r,a,s,o,h,c,l,u,d,f,g,v,m,x,p,y,R,T,b,E;e=this.modelViewMat,t=this.camPositon.getGLMatVec3(),n=this.camCenter.getGLMatVec3(),r=this.camUp.getGLMatVec3(),v=t[0],m=t[1],x=t[2],p=r[0],y=r[1],R=r[2],T=n[0],b=n[1],E=n[2],Math.abs(v-T)<i&&Math.abs(m-b)<i&&Math.abs(x-E)<i?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(e):(u=v-T,d=m-b,f=x-E,a=y*(f*=g=1/Math.hypot(u,d,f))-R*(d*=g),s=R*(u*=g)-p*f,o=p*d-y*u,(g=Math.hypot(a,s,o))?(a*=g=1/g,s*=g,o*=g):(a=0,s=0,o=0),h=d*o-f*s,c=f*a-u*o,l=u*s-d*a,(g=Math.hypot(h,c,l))?(h*=g=1/g,c*=g,l*=g):(h=0,c=0,l=0),e[0]=a,e[1]=h,e[2]=u,e[3]=0,e[4]=s,e[5]=c,e[6]=d,e[7]=0,e[8]=o,e[9]=l,e[10]=f,e[11]=0,e[12]=-(a*v+s*m+o*x),e[13]=-(h*v+c*m+l*x),e[14]=-(u*v+d*m+f*x),e[15]=1),window.x=this.modelViewMat,window.w=this.camPositon}getMatrix(){return this.generate(),{proj:this.projectionMat,view:this.modelViewMat}}}class v{constructor(e,t,n,r){this.w=t,this.h=n,this.gl=e,this.tex=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.tex),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.w,this.h,0,e.RGBA,e.UNSIGNED_BYTE,r),e.bindTexture(e.TEXTURE_2D,null)}disableMips(){let e=this.gl;e.bindTexture(e.TEXTURE_2D,this.tex),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null)}getTexture(){return this.tex}start(){this.gl.bindTexture(this.gl.TEXTURE_2D,this.tex)}end(){this.gl.bindTexture(this.gl.TEXTURE_2D,null)}getW(){return this.w}getH(){return this.h}updateTexture(e){window.i=e;let t=this.gl;t.bindTexture(t.TEXTURE_2D,this.tex),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),t.bindTexture(t.TEXTURE_2D,null)}loadImageAsync(e){const t=new Image,n=this;t.onload=function(){n.updateTexture(t)},t.src=e}}class m{constructor(){this.hashmap={}}insert(e,t,n,r=null){this.hashmap[e]={},this.hashmap[e].type=n,this.hashmap[e].initValue=t,this.hashmap[e].name=e,this.hashmap[e].ext=r}clear(){this.hashmap={}}getSourceFragment(){let e="";for(let t in this.hashmap){let n=this.hashmap[t];e+="uniform ",e+=n.type,e+=n.name,e+=";\n"}return e}bindShaderVarible(t,n){for(let r in this.hashmap){let i=this.hashmap[r],a=t.getUniformLocation(n,i.name);e.log("Binding uniform variable:"+r+"( "+i.type+")"),e.log(i.initValue),i.type==m.MAT4&&t.uniformMatrix4fv(a,!1,i.initValue),i.type==m.VEC3&&t.uniform3fv(a,i.initValue),i.type==m.VEC4&&t.uniform4fv(a,i.initValue),i.type==m.VEC2&&t.uniform2fv(a,i.initValue),i.type==m.INT&&t.uniform1i(a,i.initValue),i.type==m.FLOAT&&t.uniform1f(a,i.initValue),i.type==m.SAMPLER2D&&(0==i.initValue&&t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,i.ext),t.uniform1i(a,i.initValue))}}}m.MAT4="mat4 ",m.VEC3="vec3 ",m.VEC4="vec4 ",m.VEC2="vec2 ",m.INT="int ",m.BOOL="bool ",m.FLOAT="float ",m.SAMPLER2D="sampler2D ";class p{constructor(e){this.cam=new g,this.cam.setPerspective(45*Math.PI/180,e.canvas.height/e.canvas.width,.1,100),this.cam.setCamPosition(new o(0,0,-6)),this.cam.setCamUp(new o(0,1,0)),this.cam.setCamCenter(new o(0,0,0))}getCameraMatrix(){return f(this.cam.getMatrix().proj,this.cam.getMatrix().view)}getEye(){return this.cam.camPositon}getRay(e,t,n=0){let r=new o(e,t,n),i=d();var a,s,h,c;a=i,s=r.x,h=r.y,c=r.z,a[0]=s,a[1]=0,a[2]=0,a[3]=0,a[4]=h,a[5]=0,a[6]=0,a[7]=0,a[8]=c,a[9]=0,a[10]=0,a[11]=0,a[12]=1,a[13]=0,a[14]=0,a[15]=0;let l=d();return f(l,l,i),new o(l[0],l[4],l[8]).add(this.getEye().neg()).getGLMatVec3()}prepareShaderMap(e){e.insert("raylt",this.getRay(-1,1),m.VEC3),e.insert("raylb",this.getRay(-1,-1),m.VEC3),e.insert("rayrb",this.getRay(1,-1),m.VEC3),e.insert("rayrt",this.getRay(1,1),m.VEC3),e.insert("eye",this.getEye().getGLMatVec3(),m.VEC3)}}class R extends n{constructor(e){super(e),this.gl=e,this.vertexShader="  ",this.fragmentShader="  "}getFragShader(e){return this.fragmentShader=e.genFragmentShader(),this.fragmentShader}getVertexShader(){return this.vertexShader="\n        attribute vec4 aVertexPosition;\n        attribute vec4 aVertexColor;\n        attribute vec2 aVertexTex;\n\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n        uniform vec3 raylb;\n        uniform vec3 raylt;\n        uniform vec3 rayrb;\n        uniform vec3 rayrt;\n\n        varying highp vec3 ray;\n        varying highp vec4 color;\n        varying highp vec2 tex;\n        void main() {\n            float xp = aVertexPosition.x*0.5+0.5;\n            float yp = aVertexPosition.y*0.5+0.5;\n            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n            ray = mix(mix(raylb,raylt,yp),mix(rayrb,rayrt,yp),xp);\n            color = aVertexColor;\n            tex = aVertexTex;\n        }\n        ",this.vertexShader}getFragShaderTest(e){return this.fragmentShader="precision highp float;\n            varying highp vec3 ray;\n            void main(){\n                gl_FragColor = vec4(color);\n            }\n        ",this.fragmentShader}getShaderProgram(e){return this.getShaderProgramEx(this.getVertexShader(),this.getFragShader(e))}getLocationsInfo(e){return this.getShaderProgram(e)}}class T{static structDef_Ray(){return"\n            struct sRay{\n                vec3 origin;\n                vec3 direction;\n                vec4 color;\n            };\n        "}static structDef_Plane(){return"\n            struct sPlane{\n                vec3 x,y,z;\n                vec4 emissionColor;\n                vec4 materialColor;\n                \n            };\n        "}static structDef_Sphere(){return"\n            struct sSphere{\n                vec3 c;\n                float r;\n                vec4 emissionColor;\n                vec4 materialColor;\n                \n            };\n        "}static structDef_RayCollisionResult(){return"\n            struct sRayCollisionResult{\n                vec3 colvex;\n                vec3 colnorm;\n                bool collided;\n                vec4 emissionColor;\n                vec4 materialColor;\n                int hitType;\n            };\n        "}static structDefConcat(){let e=[T.structDef_Plane,T.structDef_Ray,T.structDef_Sphere,T.structDef_RayCollisionResult],t="";for(let n=0;n<e.length;n++)t+=e[n]();return t}static funcDef_RayPoint(){return"\n            vec3 fRayPoint(sRay ray,float t){\n                vec3 ret = ray.origin;\n                ret = ret + t * ray.direction;\n                return ret;\n            }\n        "}static funcDef_PlaneNorm(){return"\n            vec3 fPlaneNorm(sPlane p){\n                vec3 x = p.y-p.x;\n                vec3 y = p.z-p.y;\n                return cross(x,y);\n            }\n        "}static funcDef_RayPlaneIntersection(){return"\n            float fRayPlaneIntersection(sRay r,sPlane p){\n                vec3 n = fPlaneNorm(p);\n                vec3 di = r.direction;\n                vec3 or = r.origin;\n                vec3 a = p.y;\n                float rd = n.x*di.x+n.y*di.y+n.z*di.z;\n                float rn = n.x*(a.x-or.x)+n.y*(a.y-or.y)+n.z*(a.z-or.z);\n                return rn/rd;\n            }\n        "}static funcDef_RaySphereIntersection(){return"\n            float fRaySphereIntersection(sRay r,sSphere s){\n                vec3 p = r.origin-s.c;\n                vec3 d = r.direction;\n                float a = d.x*d.x+d.y*d.y+d.z*d.z;\n                float b = 2.0*(d.x*p.x+d.y*p.y+d.z*p.z);\n                float c = p.x*p.x+p.y*p.y+p.z*p.z-s.r*s.r;\n                float delta = b*b-4.0*a*c;\n                if(delta<1e-10){\n                    return -1.0;\n                }else{\n                    float sdelta = sqrt(delta);\n                    float t1 = (-b+sdelta)/(2.0*a);\n                    float t2 = (-b-sdelta)/(2.0*a);\n                    if(t1>0.0&&t2>0.0){\n                        if(t1>t2){\n                            return t2;\n                        }\n                        return t1;\n                    }\n                    if(t1>0.0&&t2<0.0){\n                        return t1;\n                    }\n                    return t2;\n                }\n                return 0.0;\n            }\n        "}static funcDef_InsidePlane(){return"\n            bool fInsidePlane(sPlane p,vec3 v){\n                vec3 v1 = p.x - v;\n                vec3 v2 = p.y - v;\n                vec3 v3 = p.z - v;\n                float s1 = length(cross(v1,v2));\n                float s2 = length(cross(v2,v3));\n                float s3 = length(cross(v3,v1));\n                float s0 = length(cross(p.y-p.x,p.z-p.x));\n                if(abs(abs(s0)-abs(s1)-abs(s2)-abs(s3))<1e-5){\n                    return true;\n                }\n                return false;\n            }\n        "}static funcDef_SpecularReflection(){return"\n            sRay fSpecularReflection(sRay inr,vec3 p,vec3 norm){\n                vec3 n = norm;\n                if(dot(inr.direction,norm)>0.0){\n                    n = -n;\n                }\n                vec3 ix = inr.direction/dot(inr.direction,n);\n                vec3 ox = ix+2.0*n;\n                vec3 o = ox/length(ox);\n                sRay ret = sRay(p,o,inr.color);\n                return ret;\n\n\n\n            }\n        "}static funcDef_RandNoiseV3(){return"\n            vec3 mod289(vec3 x) {\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n            \n            vec4 mod289(vec4 x) {\n                return x - floor(x * (1.0 / 289.0)) * 289.0;\n            }\n            \n            vec4 permute(vec4 x) {\n                return mod289(((x*34.0)+10.0)*x);\n            }\n            \n            vec4 taylorInvSqrt(vec4 r)\n            {\n                return 1.79284291400159 - 0.85373472095314 * r;\n            }\n            \n            float snoise(vec3 v)\n                { \n                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n                vec3 i  = floor(v + dot(v, C.yyy) );\n                vec3 x0 =   v - i + dot(i, C.xxx) ;\n            \n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min( g.xyz, l.zxy );\n                vec3 i2 = max( g.xyz, l.zxy );\n            \n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy; \n                vec3 x3 = x0 - D.yyy;      \n            \n                i = mod289(i); \n                vec4 p = permute( permute( permute( \n                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n            \n                float n_ = 0.142857142857; // 1.0/7.0\n                vec3  ns = n_ * D.wyz - D.xzx;\n            \n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n            \n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n            \n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n            \n                vec4 b0 = vec4( x.xy, y.xy );\n                vec4 b1 = vec4( x.zw, y.zw );\n            \n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n            \n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n            \n                vec3 p0 = vec3(a0.xy,h.x);\n                vec3 p1 = vec3(a0.zw,h.y);\n                vec3 p2 = vec3(a1.xy,h.z);\n                vec3 p3 = vec3(a1.zw,h.w);\n            \n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n            \n\n                vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                            dot(p2,x2), dot(p3,x3) ) );\n            }\n            float fRandNoiseV3(vec3 x){\n                state += snoise(x+vec3(state,state+144.13,151.49))+24.89;\n                return snoise(x+vec3(state+613.5,state+644.11,state+593.4));\n            }\n        "}static funcDef_DiffuseReflection(){return"\n            sRay fDiffuseReflection(sRay inr,vec3 p,vec3 norm){\n                vec3 n = norm;\n                if(dot(inr.direction,norm)>0.0){\n                    n = -n;\n                }\n                float dx = fRandNoiseV3(vec3(n.xyz)+vec3(21.114,4.1244,588.11))-0.5;\n                float dy = fRandNoiseV3(vec3(dx,dx,n.z))-0.5;\n                float dz = fRandNoiseV3(vec3(dy,dx,n.z))-0.5;\n                vec3 tp = vec3(dx,dy,dz)/length(vec3(dx,dy,dz));\n                vec3 rc = n + p;\n                vec3 newdir = tp + rc - p;\n                vec3 o = newdir / length(newdir);\n                sRay rt = sRay(p,o,inr.color);\n                return rt;\n            }\n        "}static funcDef_RayCollision(e=""){return"\n            sRayCollisionResult fRayCollision(sRay r){\n                float t = 1e30;\n                vec3 norm = vec3(0.0,0.0,0.0);\n                vec4 emicolor = vec4(1.0,0.0,0.0,1.0);\n                vec4 matcolor = vec4(0.0,0.0,0.0,1.0);\n                bool collided = false;\n                float tc=1e30;\n                int hitType = 0;\n                bool colc = false;\n                "+e+"\n                vec3 colp = fRayPoint(r,t);\n                sRayCollisionResult ret = sRayCollisionResult(colp,norm,collided,emicolor,matcolor,hitType);\n                return ret;\n            }\n        "}static funcDef_Raytracing(){return"\n            vec4 fRaytracing(sRay r){\n                sRay rp = r;\n                vec4 accColor = vec4(0.0,0.0,0.0,1.0);\n                vec4 accMaterial = vec4(0.5,0.5,0.5,1.0);\n                for(int i=1;i < 20;i+=1){\n                    sRayCollisionResult hit = fRayCollision(rp);\n                    if(hit.collided == false){\n                        break;\n                    }\n                    accColor = accColor + accMaterial * hit.emissionColor;\n                    accMaterial = accMaterial * hit.materialColor;\n                    if(hit.hitType==1){\n                        rp = fDiffuseReflection(rp,hit.colvex,hit.colnorm);\n                    }else if(hit.hitType==2){\n                        rp = fSpecularReflection(rp,hit.colvex,hit.colnorm);\n                    }\n                    \n                    \n                }\n                return accColor;\n            }\n        "}static funcDef_Main(){return"\n            void main(){\n                state += fRandNoiseV3(vec3(uTime,uTime+212.0,uTime+2.0));\n                float loopsf = 1.0;\n                float randsrng = 0.0001;\n                const int loops = 1;\n\n                vec3 nray = ray / length(ray);\n                vec3 rnd = vec3(1.14+state,5.14+state,1.91+state+uTime);\n                vec4 fragc = vec4(0.0,0.0,0.0,0.0);\n                for(int i=0;i<loops;i++){\n                    float r1 = fRandNoiseV3(rnd);\n                    rnd = vec3(rnd.y,rnd.z,r1);\n                    float r2 = fRandNoiseV3(rnd);\n                    rnd = vec3(rnd.y,rnd.z,r2);\n                    float r3 = fRandNoiseV3(rnd);\n                    rnd = vec3(rnd.y,rnd.z,r3);\n                    nray = nray + rnd * randsrng;\n                    nray = nray / length(nray);\n\n                    sRay r = sRay(eye,nray,vec4(0.0,0.0,0.0,0.0));\n                    fragc = fRaytracing(r)/loopsf + fragc;\n                }\n                vec4 textc = texture2D(uTexture, vec2(1.0-tex.s,tex.t));\n                fragc = vec4(min(fragc.x,1.0),min(fragc.y,1.0),min(fragc.z,1.0),1.0);\n                gl_FragColor = (textc*float(uSamples) + fragc)/(float(uSamples)+1.0);\n            }\n        "}static funcDefConcat(e){let t=[[T.funcDef_RandNoiseV3,null],[T.funcDef_DiffuseReflection,null],[T.funcDef_InsidePlane,null],[T.funcDef_PlaneNorm,null],[T.funcDef_RayPlaneIntersection,null],[T.funcDef_RaySphereIntersection,null],[T.funcDef_RayPoint,null],[T.funcDef_SpecularReflection,null],[T.funcDef_RayCollision,e.intersection],[T.funcDef_Raytracing,null],[T.funcDef_Main,null]],n="";for(let e=0;e<t.length;e++)null===t[e][1]?n+=t[e][0]():n+=t[e][0](t[e][1]);return n}static globalVarDefConcat(){return"\n            float state = 12.2;\n            varying highp vec3 ray;\n            varying highp vec4 color;\n            varying highp vec2 tex;\n        "}static uniformDefConcat(e){return null==e?"":e.getSourceFragment()}static getFragmentShader(e,t){null==e&&(e={intersection:""});let n="\n            precision highp float;\n        \n";return n+=T.uniformDefConcat(t),n+=T.globalVarDefConcat(),n+=T.structDefConcat(),n+=T.funcDefConcat(e),n}}class b{constructor(e,t,n){this.cl=new u(1,1,1,1),this.em=new u(1,1,1,1),this.tp=b.DIFFUSE,null!=e&&(this.cl=e),null!=t&&(this.em=t),null!=n&&(this.tp=n)}}b.DIFFUSE=1,b.SPECULAR=2;class E{constructor(e,t,n,r){this.vc=e,this.ra=t,this.name="RTSphere"+r,null!=this.va&&null!=this.vb&&null!=this.vc||console.log("[CGProject] RTSphere: Invalid sphere object."),this.material=new b,null!=this.material&&(this.material=n),this.uEM=this.name+"_EM",this.uCL=this.name+"_CL"}updateMap(e){e.insert(this.name+"_VC",this.vc.getGLMatVec3(),m.VEC3),e.insert(this.name+"_RA",this.ra,m.FLOAT),e.insert(this.name+"_EM",this.material.em.getGLMatVec4(),m.VEC4),e.insert(this.name+"_CL",this.material.cl.getGLMatVec4(),m.VEC4)}genObject(){let e="";return e="sSphere("+this.name+"_VC,"+this.name+"_RA,"+this.name+"_EM,"+this.name+"_CL)",e}genShaderIntersection(){return"\n\n                if(true){\n                    sSphere sp = "+this.genObject()+";\n                    tc = fRaySphereIntersection(r,sp);\n                    if(tc>0.0){\n                        vec3 ip = fRayPoint(r,tc);\n                        if(tc<t){\n                            t=tc;\n                            norm = ip - "+this.name+"_VC;\n                            emicolor = vec4("+this.uEM+");\n                            matcolor = vec4("+this.uCL+");\n                            hitType = "+this.material.tp+";\n                            collided=true;\n                        }\n                        \n                    }\n                }\n        "}}const w=new class{constructor(e){let t=document.getElementById(e);this.context=t.getContext("webgl"),this.context||window.alert("[CGProject] WGL is not supported!")}getContext(){return this.context}}("webgl_displayer").getContext();let A=new class extends n{constructor(e){super(e),this.gl=e,this.vertexShader="  ",this.fragmentShader="  "}getFragShader(){return this.fragmentShader="\n        varying lowp vec4 vColor;\n        varying highp vec4 vPosition;\n        varying highp vec3 vAmbientLight;\n        varying highp vec2 vTextureCoord;\n        uniform int uUsingTex;\n\n        uniform sampler2D uSampler;\n        int temp;\n        //Update\n        void main() {\n            highp vec4 ret;\n            if(uUsingTex==0){\n                ret = vec4(vColor.xyz * vAmbientLight,vColor.w);\n            }else{\n                highp vec4 tex = texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));\n                ret = tex;\n                \n            }\n            ret = ret * vec4(vAmbientLight,1.0);\n            gl_FragColor = ret;\n            \n        }\n        ",this.fragmentShader}getVertexShader(){return this.vertexShader="\n        attribute vec4 aVertexPosition;\n        attribute vec4 aVertexColor;\n        attribute vec2 aTextureCoord;\n\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n        uniform vec3 uAmbientLight;\n\n        varying lowp vec4 vColor;\n        varying highp vec4 vPosition;\n        varying highp vec3 vAmbientLight;\n        varying highp vec2 vTextureCoord;\n\n        void main() {\n          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n          vColor = aVertexColor;\n          vAmbientLight = uAmbientLight;\n          vTextureCoord = aTextureCoord;\n          vPosition = aVertexPosition;\n        }\n        ",this.vertexShader}getShaderProgram(){return this.getShaderProgramEx(this.getVertexShader(),this.getFragShader())}getLocationsInfo(){let e=this.getShaderProgram();return{program:e,attribLocations:{vertexPosition:this.gl.getAttribLocation(e,"aVertexPosition"),vertexColor:this.gl.getAttribLocation(e,"aVertexColor"),vertexTexture:this.gl.getAttribLocation(e,"aTextureCoord")},uniformLocations:{projectionMatrix:this.gl.getUniformLocation(e,"uProjectionMatrix"),modelViewMatrix:this.gl.getUniformLocation(e,"uModelViewMatrix"),ambientLight:this.gl.getUniformLocation(e,"uAmbientLight"),usingTex:this.gl.getUniformLocation(e,"uUsingTex"),sampler:this.gl.getUniformLocation(e,"uSampler")}}}}(w).getLocationsInfo(),C=new g;C.setOrtho(-1,1,1,-1,-1,1),C.setCamPosition(new o(0,0,-1)),C.setCamCenter(new o(0,0,0)),C.setCamUp(new o(0,1,0));let _=new u(1,1,1,1),F=new o(-1,-1,0),V=new o(-1,1,0),S=new o(1,-1,0),P=new o(1,1,0),M=new o(1,0),L=new o(1,1),D=new o(0,0),U=new o(0,1),B=new class extends class{constructor(){this.vertices=new Array,this.colors=new Array,this.texture=new Array,this.vertexlist=new Array,this.ready=!1}addVertex(e){this.vertexlist.push(e),this.ready=!1}eval(){if(!0!==this.ready){this.vertices=new Array,this.colors=new Array,this.texture=new Array;for(let e=0;e<this.vertexlist.length;e++){let t=this.vertexlist[e];this.vertices.push(t.pt.x),this.vertices.push(t.pt.y),this.vertices.push(t.pt.z),this.colors.push(t.cl.r),this.colors.push(t.cl.g),this.colors.push(t.cl.b),this.colors.push(t.cl.a),this.texture.push(t.tx.x),this.texture.push(t.tx.y)}this.ready=!0}}clear(){this.vertexlist=[],this.ready=!1}}{constructor(e,t,n,r){super(),this.set(e,t,n,r)}set(e,t,n,r){this.va=e,this.vb=t,this.vc=n,this.vd=r,this.addVertex(this.va),this.addVertex(this.vb),this.addVertex(this.vc),this.addVertex(this.vd),this.addVertex(this.vc),this.addVertex(this.vb),this.eval()}getNormalVector(){this.va.add(this)}}(new r(F,_,M),new r(V,_,L),new r(S,_,D),new r(P,_,U)),I=new class extends class{constructor(){this.vbuf=new Array,this.ambientLight=new h}addShape(e){this.vbuf.push(e)}setAmbientLight(e){this.ambientLight=e}}{constructor(e){super(),this.gl=e,this.fb=new c(e),this.usingTex=0}getFrameBuffer(){return this.fb}getGLVertexArray(){let e=this.gl,t=[],n=[],r=[],i=0;for(let e=0;e<this.vbuf.length;e++){let a=this.vbuf[e];a.eval(),t=t.concat(a.vertices),n=n.concat(a.colors),r=r.concat(a.texture),i+=a.vertexlist.length}window.w={v:t,t:r,c:n};const a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW);const s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,new Float32Array(n),e.STATIC_DRAW);const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW);let h={vb:a,cb:s,tb:o,vnum:i};return window.r=h,h}render(e,t,n){let r=this.gl;r.clearColor(0,0,0,1),r.clearDepth(1),r.enable(r.DEPTH_TEST),r.depthFunc(r.LEQUAL),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.renderInternal(e,t,n)}renderInternal(e,t,n,r){let i=this.gl,a=t.getMatrix(),s=a.proj,o=a.view;const h=this.getGLVertexArray();i.bindBuffer(i.ARRAY_BUFFER,h.vb),i.vertexAttribPointer(e.attribLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(e.attribLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,h.cb),i.vertexAttribPointer(e.attribLocations.vertexColor,4,i.FLOAT,!1,0,0),i.enableVertexAttribArray(e.attribLocations.vertexColor),this.usingTex&&(i.bindBuffer(i.ARRAY_BUFFER,h.tb),i.vertexAttribPointer(e.attribLocations.vertexTexture,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(e.attribLocations.vertexTexture)),i.useProgram(e.program),i.uniformMatrix4fv(e.uniformLocations.projectionMatrix,!1,s),i.uniformMatrix4fv(e.uniformLocations.modelViewMatrix,!1,o),i.uniform3fv(e.uniformLocations.ambientLight,this.ambientLight.light.getGLMatVec3()),i.activeTexture(i.TEXTURE0),null!=n&&n.start(),i.uniform1i(e.uniformLocations.usingTex,this.usingTex),i.uniform1i(e.uniformLocations.sampler,0),null!=r&&r.end(),i.drawArrays(i.TRIANGLES,0,h.vnum),null!=n&&n.end()}renderToTexture(e,t,n){let r=this.gl;this.fb.start(),n.start(),r.viewport(0,0,n.getW(),n.getH()),r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),this.renderInternal(e,t,null,n),n.end(),this.fb.end()}}(w);I.addShape(B),I.usingTex=1,w.enable(w.DEPTH_TEST);let O=new class{constructor(e){this.gl=e,this.shaderVar=new m,this.screen=new g,this.observer=new p(e),this.shader=new R(e),this.compiledShader=null,this.geometryList=[],this.renderOutput=[new v(e,1024,1024,null),new v(e,1024,1024,null)],this.renderOutput[0].disableMips(),this.renderOutput[1].disableMips(),this.frameBuffer=new c(e),this.frameBuffer.bindTexturePingPong(e.COLOR_ATTACHMENT0,this.renderOutput[0],this.renderOutput[0]),this.sampleCount=0,this.sheetRect=[-1,-1,0,-1,1,0,1,-1,0,1,1,0],this.sheetTex=[0,0,0,1,1,0,1,1],this.sheetColor=[0,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1],this.sheetvb=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.sheetvb),e.bufferData(e.ARRAY_BUFFER,new Float32Array(this.sheetRect),e.STATIC_DRAW),this.sheetcb=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.sheetcb),e.bufferData(e.ARRAY_BUFFER,new Float32Array(this.sheetColor),e.STATIC_DRAW),this.sheettb=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.sheettb),e.bufferData(e.ARRAY_BUFFER,new Float32Array(this.sheetTex),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),this.screen.setOrtho(-1,1,1,-1,-1,1),this.screen.setCamCenter(new o(0,0,-1)),this.screen.setCamUp(new o(0,1,0)),this.screen.setCamPosition(new o(0,0,0))}clear(){this.geometryList=[],this.shaderVar.clear()}attach(e){this.geometryList.push(e)}getRenderOutput(){return this.renderOutput[0]}loadAlternativeTexture(){this.shaderVar.insert("uTexture",0,m.SAMPLER2D,this.renderOutput[1].getTexture())}updateMap(){for(let e=0;e<this.geometryList.length;e++)this.geometryList[e].updateMap(this.shaderVar);this.observer.prepareShaderMap(this.shaderVar),this.shaderVar.insert("uProjectionMatrix",this.screen.getMatrix().proj,m.MAT4),this.shaderVar.insert("uModelViewMatrix",this.screen.getMatrix().view,m.MAT4),this.shaderVar.insert("uTime",Date.now()-1639051292614,m.FLOAT),this.shaderVar.insert("uSamples",this.sampleCount,m.INT),this.loadAlternativeTexture()}genIntersectionJudge(){let e="";for(let t=0;t<this.geometryList.length;t++)e+=this.geometryList[t].genShaderIntersection();return e}genFragmentShader(){this.updateMap();let e={intersection:this.genIntersectionJudge()};return T.getFragmentShader(e,this.shaderVar)}compile(){this.compiledShader=this.shader.getShaderProgram(this)}updateUniform(){this.shaderVar.insert("uTime",(new Date).getTime()-1639051292614,m.FLOAT),this.shaderVar.insert("uSamples",this.sampleCount,m.INT)}clear(){this.frameBuffer.start(),this.renderOutput[0].start(),gl.viewport(0,0,this.getRenderOutput().getW(),this.getRenderOutput().getH()),gl.clearColor(0,0,0,1),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT),this.renderOutput[0].end(),this.frameBuffer.end()}render(e=!1){let t=this.gl;this.frameBuffer.bindTexturePingPong(t.COLOR_ATTACHMENT0,this.renderOutput[0],this.renderOutput[1]),this.frameBuffer.start(),this.renderOutput[0].start(),t.viewport(0,0,this.getRenderOutput().getW(),this.getRenderOutput().getH()),t.clearColor(0,0,0,1),t.useProgram(this.compiledShader),this.shaderVar.bindShaderVarible(t,this.compiledShader),this.updateUniform(),this.loadAlternativeTexture(),t.bindBuffer(t.ARRAY_BUFFER,this.sheetcb),t.vertexAttribPointer(t.getAttribLocation(this.compiledShader,"aVertexColor"),4,t.FLOAT,!1,0,0),t.enableVertexAttribArray(t.getAttribLocation(this.compiledShader,"aVertexColor")),t.bindBuffer(t.ARRAY_BUFFER,this.sheetvb),t.vertexAttribPointer(t.getAttribLocation(this.compiledShader,"aVertexPosition"),3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(t.getAttribLocation(this.compiledShader,"aVertexPosition")),t.drawArrays(t.TRIANGLE_STRIP,0,4),this.sampleCount++,this.renderOutput[0].end(),this.frameBuffer.end(),this.renderOutput.reverse()}}(w),N=new o(0,-2,30),G=new o(-2,0,20),j=new o(2,0,20),X=new o(0,.4,10),Y=new o(0,-100,22),H=new o(0,20,-10),W=new o(.7,-.6,7),q=new o(-2.1,2,10),k=new b(new u(.05,.05,.05,1),new u(0,0,0,1)),J=new b(new u(1,1,1,1),new u(0,0,0,1)),K=new b(new u(1,1,1,1),new u(0,0,0,1),b.SPECULAR),Q=new b(new u(1,1,1,1),new u(12,12,12,1)),Z=(new class{constructor(e,t,n,r,i){this.va=e,this.vb=t,this.vc=n,this.name="RTPlane"+i,null!=this.va&&null!=this.vb&&null!=this.vc||console.log("[CGProject] RTPlane: Invalid plane object."),this.material=new b,null!=this.material&&(this.material=r),this.uEM=this.name+"_EM",this.uCL=this.name+"_CL"}updateMap(e){e.insert(this.name+"_VA",this.va.getGLMatVec3(),m.VEC3),e.insert(this.name+"_VB",this.vb.getGLMatVec3(),m.VEC3),e.insert(this.name+"_VC",this.vc.getGLMatVec3(),m.VEC3),e.insert(this.name+"_EM",this.material.em.getGLMatVec4(),m.VEC4),e.insert(this.name+"_CL",this.material.cl.getGLMatVec4(),m.VEC4)}genObject(){let e="";return e="sPlane("+this.name+"_VA,"+this.name+"_VB,"+this.name+"_VC,"+this.name+"_EM,"+this.name+"_CL)",e}genShaderIntersection(){return"\n                if(true){\n                    sPlane pl = "+this.genObject()+";\n                    tc = fRayPlaneIntersection(r,pl);\n                    if(tc>0.0){\n                        vec3 ip = fRayPoint(r,tc);\n                        if(fInsidePlane(pl,ip)){\n                            if(tc<t){\n                                t=tc;\n                                norm = fPlaneNorm(pl);\n                                emicolor = vec4("+this.uEM+");\n                                matcolor = vec4("+this.uCL+");\n                                hitType = "+this.material.tp+";\n                                collided=true;\n                            }\n                        }\n                    }\n                }\n            \n        "}}(N,G,j,k,"plane1"),new E(X,1,J,"sphere1")),$=new E(Y,100,k,"sphere2"),ee=new E(H,20,Q,"light"),te=(new E(q,1,Q,"light2"),new E(W,.5,K,"sphere4"));O.attach(Z),O.attach($),O.attach(ee),O.attach(te),O.compile(),O.render(),requestAnimationFrame((function e(){O.render(),I.render(A,C,O.getRenderOutput()),requestAnimationFrame(e)}))})();